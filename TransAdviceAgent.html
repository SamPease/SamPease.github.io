<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<meta content="" name="description"/>
<meta content="" name="author"/>
<script crossorigin="anonymous" src="https://use.fontawesome.com/releases/v5.15.3/js/all.js"></script>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css" rel="stylesheet"/>
<title>Trans Advice Agent</title>
<link href="bootstrap.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet"/>
<link href="all.min.css" rel="stylesheet"/>
<link href="resume.min.css" rel="stylesheet"/>
</head>
<body id="page-top">
<nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
<a class="navbar-brand js-scroll-trigger" href="#page-top">
<span class="d-block d-lg-none">Trans Advice Agent</span>
<span class="d-none d-lg-block">
<img alt="" class="img-fluid img-profile rounded-circle mx-auto mb-2" src="profile.png"/>
</span>
</a>
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul class="navbar-nav">
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="index.html">
<i class="fas fa-home"></i> Home
</a>
</li>
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="#overview">Overview</a>
</li>
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="#try-it">Try It Out</a>
</li>
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="#pipeline">How the Pipeline Works</a>
</li>
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="#tech-stack">Tech Stack</a>
</li>
<li class="nav-item">
<a class="nav-link js-scroll-trigger" href="#limitations-future">Limitations & Future Work</a>
</li>
</ul>
</div>
</nav>
<div class="container-fluid p-0">
<section class="resume-section p-3 p-lg-5 d-flex align-items-center">
  <div class="w-100">
    <h1 class="mb-0">Trans Advice Agent</h1>
    <section id="overview">
<h4>Overview:</h4>
<p>
  TransAdviceAgent is an experimental tool designed to answer transgender-related questions by compiling and synthesizing community knowledge from forums and online discussions. The focus is on questions that require community guidance rather than simple factual answers, as there are very few trans-related topics backed by comprehensive research.
</p>
<p>
  Many medical questions and practical recommendations are best answered by community forums where people share real experiences. This project aims to make that collective knowledge more accessible by using advanced natural language processing to search, summarize, and synthesize information from these community sources.
</p>
<p>
  The system uses query enhancement with synonyms to improve search relevance, retrieval of diverse sources using embedding similarity, and hierarchical summarization to provide comprehensive answers grounded in community experiences.
</p>
<p>
  Please note that this is an <b>amateur project</b> and not a professional medical resource. 
  Answers are limited to the community documents included in the system — they may be incomplete, biased, or outdated. 
  Always consult licensed healthcare providers and multiple sources when making decisions about your care.
</p>
<p>
  <b>Privacy Notice:</b> This system uses LangSmith for monitoring and logging all interactions, including your questions and the generated responses. 
  Please do not input sensitive personal information, medical details, or anything you would not want logged for analysis and improvement purposes.
</p>
<p>
Currently, the primary data source is Reddit, with plans to expand to include additional trans community forums and resources in future iterations. If you know of trans resources or communities that should be included, please let me know!
</p>
<p>
  If you have questions, feedback, or suggestions for improving this project, please reach out to me at <a href="mailto:sam@walking-stick.com">sam@walking-stick.com</a>.
</p>

</section>
    <section id="try-it">
  <div class="w-100">
    <h4>Try It Out</h4>

    <form id="questionForm">
      <div class="form-group mb-3">
        <label for="questionInput">Your Question:</label>
        <textarea class="form-control" id="questionInput" rows="3" placeholder="Type your question here..." required></textarea>
      </div>
      <button type="submit" class="btn btn-primary">Submit</button>
    </form>

    <!-- Spinner -->
    <div class="mt-3" id="loadingSpinner" style="display:none;">
      <div class="spinner-border text-primary" role="status">
        <span class="sr-only">Loading...</span>
      </div>
      <span class="ml-2" id="loadingLabel">Loading...</span>
    </div>

    <div class="mt-4" id="answerSection" style="display:none;">
      <h4>Answer:</h4>
      <p id="answerText"></p>
      <h5>Sources:</h5>
      <p class="small text-muted">Sorted by relevance.</p>
      <div id="sourcesContainer">
        <div id="sourcesList"></div>
        <nav aria-label="Sources pagination" class="mt-2">
          <ul class="pagination pagination-sm" id="sourcesPagination"></ul>
        </nav>
        <div class="d-flex justify-content-between mt-2">
          <button class="btn btn-sm btn-outline-secondary" id="sourcesPrev">Prev</button>
          <button class="btn btn-sm btn-outline-secondary" id="sourcesNext">Next</button>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  /* Ensure answer text preserves line breaks */
  #answerText {
    white-space: pre-line;
  }
</style>

<section id="pipeline">
  <h4>How the Pipeline Works</h4>
  <p>
    TransAdviceAgent processes user questions through a sophisticated multi-stage pipeline designed to surface relevant community knowledge and provide comprehensive, well-sourced answers. 
    The system emphasizes finding diverse perspectives and remains fully grounded in community-sourced documents.
  </p>

  <ol>
    <li>
      <strong>Query Enhancement</strong><br>
      The user's original question is enhanced using Claude Haiku to add relevant synonyms and alternative phrasings. 
      This critical step ensures that when the embedding model searches for similar content, it finds all relevant sources rather than missing documents due to vocabulary differences. 
      The original query is preserved for the final answering stage.
    </li>

    <li>
      <strong>Embedding-Based Retrieval</strong><br>
      Community documents are pre-chunked and stored in a FAISS vector database with SQLite metadata storage. 
      The enhanced query is embedded using the all-MiniLM-L6-v2 model and used to find semantically similar document chunks. 
      Maximal Marginal Relevance (MMR) is used to ensure diverse perspectives and avoid redundant sources.
    </li>

    <li>
      <strong>Parallel Batch Summarization</strong><br>
      Retrieved document chunks are processed in parallel batches of 10 using Claude Haiku. 
      Each batch is summarized independently to capture the key information, experiences, and perspectives while preserving important details like dates, outcomes, and any conflicting viewpoints.
    </li>

    <li>
      <strong>Hierarchical Summary Combination</strong><br>
      All batch summaries are combined by the LLM into a single, comprehensive summary that aggregates patterns, highlights frequently mentioned information, and preserves the diversity of community experiences and opinions.
    </li>

    <li>
      <strong>Final Answer Generation</strong><br>
      Using the original user question and the combined summary, Claude Haiku generates the final answer. 
      The response is designed to be comprehensive, balanced, and clearly grounded in the community sources, including both positive and negative experiences where present.
    </li>
  </ol>

  <p>
    You can view the full source code and contribute here: 
    <a href="https://github.com/SamPease/TransAdviceAgent" target="_blank">github.com/SamPease/TransAdviceAgent</a>
  </p>
</section>



  <section id="tech-stack">
        <h4>Tech Stack:</h4>
      <ul>
    <li><strong>Python</strong> — core programming language for the entire pipeline</li>
    <li><strong>FastAPI</strong> — backend web framework for the API server</li>
    <li><strong>Claude Haiku</strong> — language model for query enhancement, summarization, and answer generation</li>
    <li><strong>all-MiniLM-L6-v2</strong> — embedding model for semantic similarity search, used both locally for database creation and via Hugging Face for inference</li>
    <li><strong>LangChain/LangSmith</strong> — orchestrates the entire pipeline and provides monitoring/logging of all interactions</li>
    <li><strong>FAISS</strong> — vector database for efficient similarity search with MMR (Maximal Marginal Relevance). Uses FAISS IVFPQ (inverted file + product quantization) to reduce memory usage and enable larger database scaling by avoiding the need to load the entire embedding index into memory at runtime.</li>
    <li><strong>SQLite</strong> — lightweight database for document metadata and text storage</li>
    <li><strong>Hugging Face</strong> — hosts the pre-built FAISS index and SQLite database files created offline, and provides inference API for all-MiniLM-L6-v2 when running the web app</li>
    <li><strong>Render</strong> — cloud hosting platform for the backend web application</li>
    <li><strong>GitHub Pages</strong> — static frontend hosting for this interface</li>
    <li><strong>GitHub</strong> — version control and open source code hosting 
      (<a href="https://github.com/SamPease/TransAdviceAgent" target="_blank">view code</a>)
    </li>
  </ul>
  </section>

<section id="limitations-future">
  <h4>Limitations & Future Work</h4>
  <p>
    TransAdviceAgent is an experimental, hobby project and has several limitations that users should be aware of:
  </p>
  <ul>
    <li>
      <strong>Document Coverage:</strong> The system can only provide answers based on the documents in its database. 
      If a topic, clinician, or procedure is not well-represented, the answer may be incomplete or indicate insufficient evidence.
    </li>
    <li>
      <strong>Community Bias:</strong> Retrieved documents reflect the perspectives of those who chose to share their experiences. 
      They may not represent the full range of outcomes or experiences for a given healthcare provider or procedure.
    </li>
    <li>
      <strong>Latency:</strong> Because the system uses multiple LLM calls for summarization, synthesis, and answering, responses may be slow. 
      Additionally, the biggest barrier to response time is that the backend runs on a free hosting tier that spins down due to inactivity and can take up to two minutes to spin back up.
    </li>
    <li>
      <strong>Abbreviation Expansion:</strong> Automatic expansion of initials to full clinician names is based on a curated mapping and context. 
      Unmapped or ambiguous initials may lead to missed documents or incorrect matches.
    </li>
    <li>
      <strong>No Medical Advice:</strong> The system summarizes community-sourced information and is not a substitute for professional medical guidance. 
      Users should consult licensed providers for personal healthcare decisions.
    </li>
  </ul>

  <p>
    <strong>Future Work:</strong>
    <ul>
      <li>Expand data sources beyond Reddit to include additional trans community forums, resources, and documentation.</li>
      <li>Improve retrieval quality with additional techniques, such as sparse keyword search or hybrid dense-sparse approaches.</li>
      <li>Incorporate provenance tracking for each fact in the final answer, showing exactly which documents contributed to which statements.</li>
      <li>Optimize latency and scalability, including batching strategies and lighter-weight summarization models for faster responses.</li>
      <li>Enhance abbreviation and synonym expansion using automated context-aware methods to reduce manual mapping and increase accuracy.</li>
    </ul>
  </p>
</section>


</div>


<script src="jquery.min.js"></script>
<script src="bootstrap.bundle.min.js"></script>
<script src="jquery.easing.min.js"></script>
<script src="resume.min.js"></script>
<script>
document.getElementById("questionForm").addEventListener("submit", async function(e) {
    e.preventDefault();

    const question = document.getElementById("questionInput").value;
    const answerSection = document.getElementById("answerSection");
    const answerText = document.getElementById("answerText");
  const sourcesListEl = document.getElementById("sourcesList");
  const sourcesPaginationEl = document.getElementById("sourcesPagination");
    const spinner = document.getElementById("loadingSpinner");
    const loadingLabel = document.getElementById("loadingLabel");

    // Reset UI
    spinner.style.display = "inline-flex";
    loadingLabel.textContent = "Waking server (this may take up to a minute)…";
  answerSection.style.display = "none";
  answerText.textContent = "";
  if (sourcesListEl) {
    sourcesListEl.textContent = "";
  }
  if (sourcesPaginationEl) {
    sourcesPaginationEl.innerHTML = "";
  }

    try {
        // --- Step 1: Wake server ---
        const maxWaitTimeMs = 120000; // 2 minutes
        const delayMs = 5000;         // 5s retry
        const startTime = Date.now();
        let serverAwake = false;

        while (Date.now() - startTime < maxWaitTimeMs) {
            try {
                const res = await fetch("https://transadviceagent.onrender.com/", { method: "GET" });
                if (res.ok) {
                    serverAwake = true;
                    break;
                }
            } catch (_) {
                // ignore failures until retry
            }
            console.log("Server still waking, retrying in 5s...");
            await new Promise(resolve => setTimeout(resolve, delayMs));
        }

        if (!serverAwake) {
            throw new Error("Server did not wake within 2 minutes.");
        }

        // --- Step 2: Query backend for answer ---
        loadingLabel.textContent = "Generating answer…";

        const response = await fetch("https://transadviceagent.onrender.com/ask", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ question })
        });

        if (!response.ok) throw new Error("Failed to fetch answer from backend.");

        const data = await response.json();
        answerText.textContent = data.answer || "No answer returned.";
    // Paginated sources display (10 per page)
  const sourcesPerPage = 10;

    // Helper: isValidUrl
    function isValidUrl(u) {
      try {
        new URL(u);
        return true;
      } catch (_) {
        return false;
      }
    }

    // Helper: getUrlAndText from a source which may be a string or an object {title, url}
    function getUrlAndText(src) {
      if (typeof src === 'string') return { url: src, text: src };
      if (src && typeof src === 'object') {
        const url = src.url || src.link || src.href || null;
        const sourceName = src.source || src.source_name || 'Source';
        const title = src.title || src.text || 'Untitled';
        const text = `${sourceName}: ${title}`;
        return { url, text };
      }
      return { url: null, text: String(src) };
    }

    // Helper: render a page of sources
    let currentPage = 0;
    function renderSourcesPage(sources, page) {
      currentPage = page;
      sourcesListEl.innerHTML = '';
      const start = page * sourcesPerPage;
      const end = Math.min(start + sourcesPerPage, sources.length);
      for (let i = start; i < end; i++) {
        const src = sources[i];
        const div = document.createElement('div');
        const { url, text } = getUrlAndText(src);
        if (url && isValidUrl(url)) {
          const a = document.createElement('a');
          a.href = url;
          a.textContent = text;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          div.appendChild(a);
        } else {
          div.textContent = text + (url ? ` (${url})` : '');
        }
        sourcesListEl.appendChild(div);
      }
      // update pagination active state
      Array.from(sourcesPaginationEl.children).forEach((child, idx) => {
        child.classList.toggle('active', idx === page);
      });
      // update Prev/Next disabled state
      const prevBtn = document.getElementById('sourcesPrev');
      const nextBtn = document.getElementById('sourcesNext');
      if (prevBtn) prevBtn.disabled = page <= 0;
      if (nextBtn) nextBtn.disabled = end >= sources.length;
    }

    // Helper: build pagination controls
    function buildPagination(sources) {
      sourcesPaginationEl.innerHTML = '';
      const pageCount = Math.ceil(sources.length / sourcesPerPage);
      if (pageCount <= 1) return;

      for (let p = 0; p < pageCount; p++) {
        const li = document.createElement('li');
        li.className = 'page-item' + (p === 0 ? ' active' : '');
        const a = document.createElement('a');
        a.className = 'page-link';
        a.href = '#';
        a.textContent = (p + 1).toString();
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          renderSourcesPage(sources, p);
        });
        li.appendChild(a);
        sourcesPaginationEl.appendChild(li);
      }

      // wire Prev/Next
      const prevBtn = document.getElementById('sourcesPrev');
      const nextBtn = document.getElementById('sourcesNext');
      if (prevBtn) prevBtn.onclick = () => {
        if (currentPage > 0) renderSourcesPage(sources, currentPage - 1);
      };
      if (nextBtn) nextBtn.onclick = () => {
        const pageCount = Math.ceil(sources.length / sourcesPerPage);
        if (currentPage < pageCount - 1) renderSourcesPage(sources, currentPage + 1);
      };
    }

    if (data.sources && data.sources.length > 0) {
      // store and render first page
      const sources = data.sources;
      renderSourcesPage(sources, 0);
      buildPagination(sources);
    } else {
      sourcesListEl.textContent = 'No sources available.';
      sourcesPaginationEl.innerHTML = '';
    }
        answerSection.style.display = "block";

    } catch (error) {
        console.error(error);
  answerText.textContent = "Error fetching answer. The server might still be waking or busy — try again in a few seconds.";
  if (sourcesListEl) sourcesListEl.textContent = "";
  if (sourcesPaginationEl) sourcesPaginationEl.innerHTML = "";
        answerSection.style.display = "block";
    } finally {
        spinner.style.display = "none";
    }
});
</script>

</body>
</html>
