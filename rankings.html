<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BARSElo Explorer</title>
    
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 20px; background: #f5f5f5;
        }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { margin: 0 0 20px 0; color: #333; }
        h2, h3, h4 { color: #333; }
        .search-bar { margin-bottom: 20px; }
        .search-bar input { padding: 10px; width: 60%; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; }
        .search-bar button { padding: 10px 20px; margin-left: 8px; font-size: 14px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .search-bar button:hover { background: #0052a3; }
        .search-results { margin-top: 10px; color: #666; }
        .tabs { display: flex; border-bottom: 2px solid #ddd; margin-bottom: 20px; }
        .tab { padding: 12px 24px; cursor: pointer; border: none; background: none; font-size: 14px; color: #666; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .tab:hover { color: #0066cc; }
        .tab.active { color: #0066cc; border-bottom-color: #0066cc; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; }
        th { font-weight: 600; background: #f8f9fa; cursor: pointer; user-select: none; }
        th:hover { background: #e9ecef; }
        th.sorted-asc::after { content: " ▲"; font-size: 10px; }
        th.sorted-desc::after { content: " ▼"; font-size: 10px; }
        tr:hover { background: #f8f9fa; }
        td a { color: #0066cc; text-decoration: none; }
        td a:hover { text-decoration: underline; }
        .back-link { display: inline-block; margin-bottom: 15px; color: #0066cc; text-decoration: none; }
        .back-link:hover { text-decoration: underline; }
        .detail-container { display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-start; }
        .detail-info { flex: 1; min-width: 300px; }
        .detail-chart { flex: 2; min-width: 600px; }
        .player-summary { margin-bottom: 16px; }
        .player-chart-block { margin: 12px 0 8px 0; }
        .team-chart-block { margin: 12px 0 8px 0; }
        .player-teams-block { margin-top: 16px; }
        .roster-table { width: 100%; margin-top: 10px; }
        .roster-table th, .roster-table td { padding: 8px; font-size: 13px; }
        .loading { text-align: center; padding: 40px; color: #666; }
        .filter-input { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .date-picker { padding: 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; }
        .info-text { color: #666; font-size: 13px; margin: 8px 0; }
        .changes-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        @media (max-width: 1000px) { .changes-grid { grid-template-columns: 1fr; } }
        /* Wider, no-wrap Win % column in Changes tab */
        .win-pct-col { white-space: nowrap; min-width: 240px; }
        /* Win % wideners for roster/teams tables */
        .roster-win-pct { white-space: nowrap; min-width: 240px; }
        /* Compact changes tables to avoid overflow */
        .changes-table { font-size: 13px; }
        .changes-table th, .changes-table td { padding: 8px 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>BARSElo Explorer</h1>
        <div class="search-bar">
            <input type="text" id="searchInput" placeholder="Find player or team (press Enter or click Go)">
            <button onclick="handleSearch()">Go</button>
            <div class="search-results" id="searchResults"></div>
        </div>
        <div class="tabs">
            <button class="tab active" data-tab="players" onclick="switchTab('players')">Players</button>
            <button class="tab" data-tab="teams" onclick="switchTab('teams')">Teams</button>
            <button class="tab" data-tab="changes" onclick="switchTab('changes')">Changes</button>
            <button class="tab" data-tab="compare" onclick="switchTab('compare')">Compare</button>
        </div>
        <div id="pageContent" class="loading">Loading data...</div>
    </div>
    
    <!-- Data is fetched dynamically below; cache-busted to avoid stale loads -->
    <script>
// Global state
let DATA = null;
let currentTab = 'players';
let currentSort = { table: 'players', column: 'current_elo', direction: 'desc' };
// Changes tab sort state
let changesSort = {
    players: { column: 'rank_change', direction: 'desc' },
    teams: { column: 'win_pct', direction: 'desc' }
};
// Roster sort state
let rosterSort = { column: 'current_elo', direction: 'desc' };
let LAST_ROSTER_TEAM = null;
let LAST_ROSTER_DATA = [];
let LAST_CHANGES_DATA = { players: [], teams: [] };
let TEAM_ELO_SUMMARY = {};
const INITIAL_ELO = 1000;

// Load data
window.addEventListener('DOMContentLoaded', async () => {
    try {
        // Fetch from GitHub with cache busting timestamp
        const dataUrl = 'https://raw.githubusercontent.com/SamPease/BARSElo/main/static-site/data/elo_data.json?t=' + Date.now();
        const response = await fetch(dataUrl, { cache: 'no-store' });
        if (!response.ok) throw new Error('HTTP ' + response.status);
        DATA = await response.json();
        console.log('✓ Data loaded:', DATA.metadata);
        TEAM_ELO_SUMMARY = computeTeamEloSummary();
        handleRoute();
        window.addEventListener('hashchange', handleRoute);
    } catch (error) {
        document.getElementById('pageContent').innerHTML = 
            `<p style="color: red;">Error loading data: ${error.message}</p>
             <p style="color: #666;">Make sure the <a href="https://github.com/SamPease/BARSElo" target="_blank">BARSElo repository</a> is public and the data file exists at <code>static-site/data/elo_data.json</code></p>`;
    }
});

// Routing
function handleRoute() {
    const hash = window.location.hash.slice(1) || '';
    if (hash.startsWith('/player/')) {
        showPlayerPage(decodeURIComponent(hash.slice(8)));
        setActiveTab('players');
    } else if (hash.startsWith('/team/')) {
        showTeamPage(decodeURIComponent(hash.slice(6)));
        setActiveTab('teams');
    } else if (hash === '/teams') {
        showTeamsTab();
        setActiveTab('teams');
    } else if (hash === '/changes') {
        showChangesTab();
        setActiveTab('changes');
    } else if (hash === '/compare') {
        showCompareTab();
        setActiveTab('compare');
    } else {
        showPlayersTab();
        setActiveTab('players');
    }
}

function navigate(path) { window.location.hash = path; }

function switchTab(tab) {
    currentTab = tab;
    if (tab === 'players') navigate('/');
    else if (tab === 'teams') navigate('/teams');
    else if (tab === 'changes') navigate('/changes');
    else if (tab === 'compare') navigate('/compare');
}

function setActiveTab(tab) {
    document.querySelectorAll('.tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
    });
}

// Search
function handleSearch() {
    const query = document.getElementById('searchInput').value.trim().toLowerCase();
    if (!query) return;
    
    const players = Object.keys(DATA.players).filter(p => p.toLowerCase().includes(query));
    const teams = Object.keys(DATA.teams).filter(t => t.toLowerCase().includes(query));
    
    const exactPlayers = players.filter(p => p.toLowerCase() === query);
    const exactTeams = teams.filter(t => t.toLowerCase() === query);
    
    if (exactPlayers.length === 1) { navigate('/player/' + encodeURIComponent(exactPlayers[0])); return; }
    if (exactTeams.length === 1) { navigate('/team/' + encodeURIComponent(exactTeams[0])); return; }
    if (players.length === 1 && teams.length === 0) { navigate('/player/' + encodeURIComponent(players[0])); return; }
    if (teams.length === 1 && players.length === 0) { navigate('/team/' + encodeURIComponent(teams[0])); return; }
    
    const results = document.getElementById('searchResults');
    if (players.length === 0 && teams.length === 0) {
        results.textContent = 'No matches';
    } else {
        let html = '<div style="margin-top: 10px;">';
        if (teams.length > 0) {
            html += '<strong>Teams:</strong> ';
            html += teams.slice(0, 5).map(t => `<a href="#/team/${encodeURIComponent(t)}">${escapeHtml(t)}</a>`).join(', ');
            if (teams.length > 5) html += ` (+${teams.length - 5} more)`;
        }
        if (players.length > 0) {
            if (teams.length > 0) html += '<br>';
            html += '<strong>Players:</strong> ';
            html += players.slice(0, 5).map(p => `<a href="#/player/${encodeURIComponent(p)}">${escapeHtml(p)}</a>`).join(', ');
            if (players.length > 5) html += ` (+${players.length - 5} more)`;
        }
        html += '</div>';
        results.innerHTML = html;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('searchInput')?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleSearch();
    });
});

// Players tab
function showPlayersTab() {
    const players = Object.entries(DATA.players).map(([name, stats]) => ({
        name, ...stats,
        win_pct: stats.games > 0 ? (stats.wins + 0.5 * stats.draws) / stats.games : null
    }));
    
    if (currentSort.table !== 'players') currentSort = { table: 'players', column: 'current_elo', direction: 'desc' };
    sortData(players, currentSort.column, currentSort.direction);
    
    let html = `<p>Click a player name to view details.</p>
        <input type="text" class="filter-input" placeholder="Filter players..." onkeyup="filterTable('playerTable', 0)">
        <table id="playerTable"><thead><tr>
            <th onclick="sortPlayersTable('name')">Player</th>
            <th onclick="sortPlayersTable('current_elo')">ELO</th>
            <th onclick="sortPlayersTable('peak_elo')">Peak</th>
            <th onclick="sortPlayersTable('min_elo')">Min</th>
            <th onclick="sortPlayersTable('win_pct')">Win %</th>
            <th onclick="sortPlayersTable('games')">Games</th>
            <th onclick="sortPlayersTable('last_played')">Last Played</th>
        </tr></thead><tbody>`;
    
    players.forEach(p => {
        const wp = p.win_pct !== null ? `${(p.win_pct*100).toFixed(1)}% (W:${p.wins} L:${p.losses} T:${p.draws})` : '';
        const lp = p.last_played ? new Date(p.last_played).toLocaleDateString() : 'Never';
        html += `<tr>
            <td><a href="#/player/${encodeURIComponent(p.name)}">${escapeHtml(p.name)}</a></td>
            <td>${p.current_elo?.toFixed(2) ?? 'N/A'}</td>
            <td>${p.peak_elo?.toFixed(2) ?? 'N/A'}</td>
            <td>${p.min_elo?.toFixed(2) ?? 'N/A'}</td>
            <td>${wp}</td>
            <td>${p.games}</td>
            <td>${lp}</td>
        </tr>`;
    });
    
    html += '</tbody></table>';
    document.getElementById('pageContent').innerHTML = html;
    updateSortIndicators('playerTable', currentSort.column, currentSort.direction);
}

// Teams tab
function showTeamsTab() {
    const teams = Object.entries(DATA.teams).map(([name, stats]) => ({
        name, ...stats,
        win_pct: stats.games > 0 ? (stats.wins + 0.5 * stats.draws) / stats.games : null,
        final_elo: TEAM_ELO_SUMMARY[name]?.final_elo ?? null,
        current_elo_avg: TEAM_ELO_SUMMARY[name]?.current_elo ?? null,
        starting_elo: TEAM_ELO_SUMMARY[name]?.starting_elo ?? null
    }));
    
    // Add change_elo calculated field
    teams.forEach(t => {
        if (t.final_elo !== null && t.starting_elo !== null) {
            t.change_elo = t.final_elo - t.starting_elo;
        } else {
            t.change_elo = null;
        }
    });
    
    // Default sort by change_elo
    if (currentSort.table !== 'teams') currentSort = { table: 'teams', column: 'change_elo', direction: 'desc' };
    sortData(teams, currentSort.column, currentSort.direction);
    
    let html = `<p>Click a team name to view details.</p>
        <input type="text" class="filter-input" placeholder="Filter teams..." onkeyup="filterTable('teamTable', 0)">
        <table id="teamTable"><thead><tr>
            <th onclick="sortTeamsTable('name')">Team</th>
            <th onclick="sortTeamsTable('current_elo_avg')">Current ELO</th>
            <th onclick="sortTeamsTable('change_elo')">Change in ELO</th>
            <th onclick="sortTeamsTable('final_elo')">Final ELO</th>
            <th onclick="sortTeamsTable('starting_elo')">Starting ELO</th>
            <th class="win-pct-col" onclick="sortTeamsTable('win_pct')">Win %</th>
            <th onclick="sortTeamsTable('games')">Games</th>
            <th onclick="sortTeamsTable('last_game')">Last Played</th>
        </tr></thead><tbody>`;
    
    teams.forEach(t => {
        const wp = t.win_pct !== null ? `${(t.win_pct*100).toFixed(1)}% (W:${t.wins} L:${t.losses} T:${t.draws})` : '';
        const lp = t.last_game ? new Date(t.last_game).toLocaleDateString() : 'Never';
        const changeElo = t.change_elo !== null ? t.change_elo.toFixed(2) : 'N/A';
        const changeStyle = t.change_elo !== null && t.change_elo !== 0 ? (t.change_elo > 0 ? 'color: green;' : 'color: red;') : '';
        html += `<tr>
            <td><a href="#/team/${encodeURIComponent(t.name)}">${escapeHtml(t.name)}</a></td>
            <td>${t.current_elo_avg?.toFixed(2) ?? 'N/A'}</td>
            <td style="${changeStyle}">${changeElo}</td>
            <td>${t.final_elo?.toFixed(2) ?? 'N/A'}</td>
            <td>${t.starting_elo?.toFixed(2) ?? 'N/A'}</td>
            <td class="win-pct-col">${wp}</td>
            <td>${t.games}</td>
            <td>${lp}</td>
        </tr>`;
    });
    
    html += '</tbody></table>';
    document.getElementById('pageContent').innerHTML = html;
    updateSortIndicators('teamTable', currentSort.column, currentSort.direction);
}

// Changes tab
function showChangesTab() {
    const timestamps = DATA.elo_history.timestamps;
    const lastDate = timestamps.length > 0 ? timestamps[timestamps.length - 1].split('T')[0] : new Date().toISOString().split('T')[0];
    
    let html = `<h3>ELO Changes by Date</h3>
        <label>Select date: <input type="date" class="date-picker" id="changesDatePicker" value="${lastDate}" onchange="updateChangesData()"></label>
        <p class="info-text">Change from the datapoint immediately before the selected date up to the last datapoint on that date.</p>
        <div class="changes-grid">
            <div><h4>Teams</h4><div id="teamsChangesContainer"></div></div>
            <div><h4>Players</h4><div id="playersChangesContainer"></div></div>
        </div>`;
    
    document.getElementById('pageContent').innerHTML = html;
    updateChangesData();
}

// Compare tab
function showCompareTab() {
    let html = `<h3>Compare Players or Teams</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
            <div>
                <h4>First Item</h4>
                <input type="text" id="compareInput1" placeholder="Enter player or team name..." style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px;">
            </div>
            <div>
                <h4>Second Item</h4>
                <input type="text" id="compareInput2" placeholder="Enter player or team name..." style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px;">
            </div>
        </div>
        <button onclick="updateCompareDisplay()" style="padding: 8px 16px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 20px;">Compare</button>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px;">
            <div id="compareData1"></div>
            <div id="compareData2"></div>
            <div id="compareHeadToHead" style="grid-column: 1 / span 2;"></div>
            <div id="compareSharedTeams" style="grid-column: 1 / span 2;"></div>
            <div id="compareEloChart" style="grid-column: 1 / span 2;"></div>
        </div>`;
    
    document.getElementById('pageContent').innerHTML = html;
    
    // Allow Enter key to trigger compare
    document.addEventListener('keypress', (e) => {
        const input1 = document.getElementById('compareInput1');
        const input2 = document.getElementById('compareInput2');
        if ((e.target === input1 || e.target === input2) && e.key === 'Enter') {
            updateCompareDisplay();
        }
    });
}

function updateCompareDisplay() {
    const input1 = document.getElementById('compareInput1')?.value.trim() || '';
    const input2 = document.getElementById('compareInput2')?.value.trim() || '';
    
    const data1 = getCompareData(input1);
    // If first item is found, restrict second search to same type
    const restrictType = data1 ? data1.type : null;
    const data2 = getCompareData(input2, restrictType);
    
    const container1 = document.getElementById('compareData1');
    const container2 = document.getElementById('compareData2');
    const h2hContainer = document.getElementById('compareHeadToHead');
    
    if (data1 && data2) {
        // Both found: render side-by-side comparison with h2h in middle
        container1.innerHTML = formatCompareDataWithComparison(data1, data2, true);
        container2.innerHTML = formatCompareDataWithComparison(data2, data1, false);
        const h2hData = getHeadToHeadData(data1, data2);
        if (h2hData) {
            h2hContainer.innerHTML = formatHeadToHeadData(h2hData);
        } else {
            h2hContainer.innerHTML = '<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;"><p style="color: #999; text-align: center;">No head-to-head matches found.</p></div>';
        }

        const sharedTeamsData = getSharedTeamsData(data1, data2);
        const sharedTeamsContainer = document.getElementById('compareSharedTeams');
        if (sharedTeamsData && sharedTeamsData.rows.length > 0) {
            sharedTeamsContainer.innerHTML = formatSharedTeamsData(sharedTeamsData.rows, sharedTeamsData.summary);
        } else {
            sharedTeamsContainer.innerHTML = '';
        }

        renderCompareEloChart(data1, data2);
    } else if (data1) {
        container1.innerHTML = formatCompareData(data1, input1);
        const typeMsg = restrictType ? ` (only ${restrictType}s allowed)` : '';
        container2.innerHTML = input2 ? `<p style="color: #999;">No ${restrictType || 'player or team'} found${typeMsg}.</p>` : '';
        h2hContainer.innerHTML = '';
        document.getElementById('compareSharedTeams').innerHTML = '';
        document.getElementById('compareEloChart').innerHTML = '';
    } else if (data2) {
        container1.innerHTML = input1 ? '<p style="color: #999;">No player or team found.</p>' : '';
        container2.innerHTML = formatCompareData(data2, input2);
        h2hContainer.innerHTML = '';
        document.getElementById('compareSharedTeams').innerHTML = '';
        document.getElementById('compareEloChart').innerHTML = '';
    } else {
        container1.innerHTML = input1 ? '<p style="color: #999;">No player or team found.</p>' : '';
        const typeMsg = restrictType ? ` (only ${restrictType}s allowed)` : '';
        container2.innerHTML = input2 ? `<p style="color: #999;">No ${restrictType || 'player or team'} found${typeMsg}.</p>` : '';
        h2hContainer.innerHTML = '';
        document.getElementById('compareSharedTeams').innerHTML = '';
        document.getElementById('compareEloChart').innerHTML = '';
    }
}

function getCompareData(name, restrictType = null) {
    if (!name) return null;
    
    // Case-insensitive search: try exact match first, then partial match
    const nameLower = name.toLowerCase();
    let playerMatch = null;
    let teamMatch = null;
    
    // Exact match
    if (!restrictType || restrictType === 'player') {
        for (const [key, val] of Object.entries(DATA.players)) {
            if (key.toLowerCase() === nameLower) {
                playerMatch = key;
                break;
            }
        }
    }
    if (!restrictType || restrictType === 'team') {
        for (const [key, val] of Object.entries(DATA.teams)) {
            if (key.toLowerCase() === nameLower) {
                teamMatch = key;
                break;
            }
        }
    }
    
    // Partial match if no exact match
    if (!playerMatch && (!restrictType || restrictType === 'player')) {
        for (const key of Object.keys(DATA.players)) {
            if (key.toLowerCase().includes(nameLower)) {
                playerMatch = key;
                break;
            }
        }
    }
    if (!teamMatch && (!restrictType || restrictType === 'team')) {
        for (const key of Object.keys(DATA.teams)) {
            if (key.toLowerCase().includes(nameLower)) {
                teamMatch = key;
                break;
            }
        }
    }
    
    // Use whichever we found (prefer exact match by checking both)
    if (playerMatch && !teamMatch) {
        const player = DATA.players[playerMatch];
        const allElos = Object.values(DATA.players).map(p => p.current_elo).filter(e => e !== null).sort((a, b) => b - a);
        const rank = player.current_elo ? allElos.indexOf(player.current_elo) + 1 : null;
        const percentile = rank ? (100 * (allElos.length - rank + 1) / allElos.length).toFixed(1) : null;
        const winPct = player.games > 0 ? (100 * (player.wins + 0.5 * player.draws) / player.games).toFixed(1) : 'N/A';
        
        return {
            type: 'player',
            name: playerMatch,
            data: {
                'ELO': player.current_elo?.toFixed(2) ?? 'N/A',
                'Rank': rank ? `#${rank}` : 'N/A',
                'Percentile': percentile ? `${percentile}%` : 'N/A',
                'Peak ELO': player.peak_elo?.toFixed(2) ?? 'N/A',
                'Min ELO': player.min_elo?.toFixed(2) ?? 'N/A',
                'Record': `${player.wins}-${player.losses}-${player.draws}`,
                'Win %': winPct,
                'Games': player.games,
                'Last Played': player.last_played ? new Date(player.last_played).toLocaleDateString() : 'Never'
            }
        };
    }
    
    if (teamMatch && !playerMatch) {
        const team = DATA.teams[teamMatch];
        const teamElo = TEAM_ELO_SUMMARY[teamMatch] || {};
        const allTeamFinalElos = Object.values(TEAM_ELO_SUMMARY).map(t => t.final_elo).filter(e => e !== null).sort((a, b) => b - a);
        const finalRank = teamElo.final_elo !== null && teamElo.final_elo !== undefined ? allTeamFinalElos.indexOf(teamElo.final_elo) + 1 : null;
        const finalPercentile = finalRank ? (100 * (allTeamFinalElos.length - finalRank + 1) / allTeamFinalElos.length).toFixed(1) : null;
        const winPct = team.games > 0 ? (100 * (team.wins + 0.5 * team.draws) / team.games).toFixed(1) : 'N/A';
        
        return {
            type: 'team',
            name: teamMatch,
            data: {
                'Final ELO': teamElo.final_elo?.toFixed(2) ?? 'N/A',
                'Final Rank': finalRank ? `#${finalRank}` : 'N/A',
                'Final Percentile': finalPercentile ? `${finalPercentile}%` : 'N/A',
                'Current ELO': teamElo.current_elo?.toFixed(2) ?? team.current_elo?.toFixed(2) ?? 'N/A',
                'Starting ELO': teamElo.starting_elo?.toFixed(2) ?? 'N/A',
                'ELO Change': teamElo.final_elo && teamElo.starting_elo ? (teamElo.final_elo - teamElo.starting_elo).toFixed(2) : 'N/A',
                'Record': `${team.wins}-${team.losses}-${team.draws}`,
                'Win %': winPct,
                'Games': team.games,
                'First Game': team.first_game ? new Date(team.first_game).toLocaleDateString() : 'Never',
                'Last Game': team.last_game ? new Date(team.last_game).toLocaleDateString() : 'Never'
            }
        };
    }
    
    // If both match, prefer based on restrictType or player if neither restricted
    if (playerMatch && teamMatch) {
        const usePlayer = !restrictType || restrictType === 'player';
        if (usePlayer) {
            const player = DATA.players[playerMatch];
            const allElos = Object.values(DATA.players).map(p => p.current_elo).filter(e => e !== null).sort((a, b) => b - a);
            const rank = player.current_elo ? allElos.indexOf(player.current_elo) + 1 : null;
            const percentile = rank ? (100 * (allElos.length - rank + 1) / allElos.length).toFixed(1) : null;
            const winPct = player.games > 0 ? (100 * (player.wins + 0.5 * player.draws) / player.games).toFixed(1) : 'N/A';
            
            return {
                type: 'player',
                name: playerMatch,
                data: {
                    'ELO': player.current_elo?.toFixed(2) ?? 'N/A',
                    'Rank': rank ? `#${rank}` : 'N/A',
                    'Percentile': percentile ? `${percentile}%` : 'N/A',
                    'Peak ELO': player.peak_elo?.toFixed(2) ?? 'N/A',
                    'Min ELO': player.min_elo?.toFixed(2) ?? 'N/A',
                    'Record': `${player.wins}-${player.losses}-${player.draws}`,
                    'Win %': winPct,
                    'Games': player.games,
                    'Last Played': player.last_played ? new Date(player.last_played).toLocaleDateString() : 'Never'
                }
            };
        } else {
            const team = DATA.teams[teamMatch];
            const teamElo = TEAM_ELO_SUMMARY[teamMatch] || {};
            const allTeamFinalElos = Object.values(TEAM_ELO_SUMMARY).map(t => t.final_elo).filter(e => e !== null).sort((a, b) => b - a);
            const finalRank = teamElo.final_elo !== null && teamElo.final_elo !== undefined ? allTeamFinalElos.indexOf(teamElo.final_elo) + 1 : null;
            const finalPercentile = finalRank ? (100 * (allTeamFinalElos.length - finalRank + 1) / allTeamFinalElos.length).toFixed(1) : null;
            const winPct = team.games > 0 ? (100 * (team.wins + 0.5 * team.draws) / team.games).toFixed(1) : 'N/A';
            
            return {
                type: 'team',
                name: teamMatch,
                data: {
                    'Final ELO': teamElo.final_elo?.toFixed(2) ?? 'N/A',
                    'Final Rank': finalRank ? `#${finalRank}` : 'N/A',
                    'Final Percentile': finalPercentile ? `${finalPercentile}%` : 'N/A',
                    'Current ELO': teamElo.current_elo?.toFixed(2) ?? team.current_elo?.toFixed(2) ?? 'N/A',
                    'Starting ELO': teamElo.starting_elo?.toFixed(2) ?? 'N/A',
                    'ELO Change': teamElo.final_elo && teamElo.starting_elo ? (teamElo.final_elo - teamElo.starting_elo).toFixed(2) : 'N/A',
                    'Record': `${team.wins}-${team.losses}-${team.draws}`,
                    'Win %': winPct,
                    'Games': team.games,
                    'First Game': team.first_game ? new Date(team.first_game).toLocaleDateString() : 'Never',
                    'Last Game': team.last_game ? new Date(team.last_game).toLocaleDateString() : 'Never'
                }
            };
        }
    }
    
    return null;
}

function formatCompareData(compareData, name) {
    const data = compareData.data;
    let html = `<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;">
        <h4 style="margin-top: 0;"><a href="#/${compareData.type === 'player' ? 'player' : 'team'}/${encodeURIComponent(compareData.name)}" style="color: #0066cc; text-decoration: none;">${escapeHtml(compareData.name)}</a></h4>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;">${compareData.type === 'player' ? 'Player' : 'Team'}</p>`;
    
    Object.entries(data).forEach(([key, value]) => {
        html += `<div style="margin-bottom: 8px; display: flex; justify-content: space-between;">
            <span style="font-weight: 500; color: #333;">${escapeHtml(key)}:</span>
            <span style="color: #666;">${escapeHtml(String(value))}</span>
        </div>`;
    });
    
    html += `</div>`;
    return html;
}

function formatHeadToHeadData(h2hData) {
    let html = `<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;">
        <h4 style="margin-top: 0; text-align: center;">Head-to-Head</h4>
        <p style="text-align: center; font-size: 14px; margin-bottom: 8px;"><strong>Record: ${h2hData.record}</strong></p>
        <p style="text-align: center; font-size: 13px; margin-bottom: 15px;">Point Differential: ${h2hData.pointDiff > 0 ? '+' : ''}${h2hData.pointDiff}</p>
        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
            <thead>
                <tr style="background: #e9ecef;">
                    <th style="padding: 6px; text-align: left; border-bottom: 1px solid #ddd; font-size: 11px;">Date</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">P1 Team</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">P2 Team</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Result Only</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Tournament Game</th>
                </tr>
            </thead>
            <tbody>
                ${h2hData.games.map(g => `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 6px; font-size: 11px;">${new Date(g.datetime).toLocaleDateString()}</td>
                        <td style="padding: 6px; text-align: center; font-size: 11px; ${g.p1Score > g.p2Score ? 'color: green; font-weight: 600;' : g.p1Score < g.p2Score ? 'color: red; font-weight: 600;' : 'color: gray;'}">${g.p1TeamName} ${g.p1Score}</td>
                        <td style="padding: 6px; text-align: center; font-size: 11px; ${g.p2Score > g.p1Score ? 'color: green; font-weight: 600;' : g.p2Score < g.p1Score ? 'color: red; font-weight: 600;' : 'color: gray;'}">${g.p2TeamName} ${g.p2Score}</td>
                        <td style="padding: 6px; text-align: center; font-size: 11px; color: #555;">${g.outcomeOnly ? 'true' : ''}</td>
                        <td style="padding: 6px; text-align: center; font-size: 11px; color: #555;">${g.tournamentGame ? 'true' : ''}</td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    </div>`;
    return html;
}

function formatCompareDataWithComparison(primary, secondary, isPrimary) {
    const data = primary.data;
    let html = `<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;">
        <h4 style="margin-top: 0;"><a href="#/${primary.type === 'player' ? 'player' : 'team'}/${encodeURIComponent(primary.name)}" style="color: #0066cc; text-decoration: none;">${escapeHtml(primary.name)}</a></h4>
        <p style="font-size: 12px; color: #666; margin-bottom: 10px;">${primary.type === 'player' ? 'Player' : 'Team'}</p>`;
    
    // Metrics where higher is better
    const higherIsBetter = ['ELO', 'Peak ELO', 'Min ELO', 'Percentile', 'Final Percentile', 'Win %', 'Final ELO', 'Current ELO', 'Starting ELO', 'ELO Change'];
    // Metrics where lower is better
    const lowerIsBetter = ['Rank', 'Final Rank'];
    
    Object.entries(data).forEach(([key, value]) => {
        let bgColor = 'transparent';
        let textColor = '#666';
        
        // Try to parse and compare numeric values
        const primaryVal = parseFloat(value);
        const secondaryVal = secondary.data[key] ? parseFloat(secondary.data[key]) : null;
        
        if (!isNaN(primaryVal) && secondaryVal !== null && !isNaN(secondaryVal) && primaryVal !== secondaryVal) {
            if (higherIsBetter.includes(key) && primaryVal > secondaryVal) {
                bgColor = '#d4edda';
                textColor = '#155724';
            } else if (higherIsBetter.includes(key) && primaryVal < secondaryVal) {
                bgColor = '#f8d7da';
                textColor = '#721c24';
            } else if (lowerIsBetter.includes(key) && primaryVal < secondaryVal) {
                bgColor = '#d4edda';
                textColor = '#155724';
            } else if (lowerIsBetter.includes(key) && primaryVal > secondaryVal) {
                bgColor = '#f8d7da';
                textColor = '#721c24';
            }
        }
        
        html += `<div style="margin-bottom: 8px; display: flex; justify-content: space-between; padding: 6px; background-color: ${bgColor}; border-radius: 3px;">
            <span style="font-weight: 500; color: #333;">${escapeHtml(key)}:</span>
            <span style="color: ${textColor};">${escapeHtml(String(value))}</span>
        </div>`;
    });
    
    html += `</div>`;
    return html;
}

function getHeadToHeadData(player1, player2) {
    const games = DATA.games_with_scores || [];
    let h2hGames = [];
    let wins = 0, losses = 0, draws = 0;
    let pointsFor = 0, pointsAgainst = 0;
    const toBool = (val) => val === true || val === 1 || val === '1' || val === 'true';
    
    if (player1.type === 'player' && player2.type === 'player') {
        // Player vs Player: find games where their teams played each other
        const player1Teams = DATA.players[player1.name]?.teams || [];
        const player2Teams = DATA.players[player2.name]?.teams || [];
        
        for (const game of games) {
            const p1InGame = player1Teams.includes(game.team1) || player1Teams.includes(game.team2);
            const p2InGame = player2Teams.includes(game.team1) || player2Teams.includes(game.team2);
            
            if (p1InGame && p2InGame) {
                // Disambiguate which side each player was on (handles players who have been on both teams historically)
                const p1Has1 = player1Teams.includes(game.team1);
                const p1Has2 = player1Teams.includes(game.team2);
                const p2Has1 = player2Teams.includes(game.team1);
                const p2Has2 = player2Teams.includes(game.team2);

                let p1Team = null;
                if (p1Has1 && !p1Has2) p1Team = game.team1;
                else if (p1Has2 && !p1Has1) p1Team = game.team2;
                else if (p1Has1 && p1Has2) {
                    if (p2Has1 && !p2Has2) p1Team = game.team2;
                    else if (p2Has2 && !p2Has1) p1Team = game.team1;
                    else p1Team = game.team1; // fallback
                }

                let p2Team = null;
                if (p2Has1 && !p2Has2) p2Team = game.team1;
                else if (p2Has2 && !p2Has1) p2Team = game.team2;
                else if (p2Has1 && p2Has2) {
                    if (p1Team === game.team1) p2Team = game.team2;
                    else if (p1Team === game.team2) p2Team = game.team1;
                    else p2Team = game.team1; // fallback
                }

                if (!p1Team) p1Team = p2Team === game.team1 ? game.team2 : game.team1;
                if (!p2Team) p2Team = p1Team === game.team1 ? game.team2 : game.team1;

                // If both players are on the same team in this game, treat it as a shared team appearance (not head-to-head)
                if (p1Team === p2Team) continue;

                // Determine result from player1's perspective
                let result = 'D';
                
                if (p1Team === game.team1) {
                    if (game.score1 > game.score2) result = 'W';
                    else if (game.score1 < game.score2) result = 'L';
                } else {
                    if (game.score2 > game.score1) result = 'W';
                    else if (game.score2 < game.score1) result = 'L';
                }
                
                if (result === 'W') wins++;
                else if (result === 'L') losses++;
                else draws++;
                
                const outcomeOnly = toBool(game.outcome_only ?? game.outcomeOnly);
                const tournamentGame = toBool(game.tournament ?? game.tournamentGame);

                // Points for/against from player1's perspective
                if (!outcomeOnly) {
                    if (p1Team === game.team1) {
                        pointsFor += game.score1;
                        pointsAgainst += game.score2;
                    } else {
                        pointsFor += game.score2;
                        pointsAgainst += game.score1;
                    }
                }
                
                const p1Score = p1Team === game.team1 ? game.score1 : game.score2;
                const p2Score = p2Team === game.team1 ? game.score1 : game.score2;
                h2hGames.push({
                    datetime: game.datetime,
                    p1TeamName: p1Team,
                    p2TeamName: p2Team,
                    p1Score,
                    p2Score,
                    outcomeOnly,
                    tournamentGame,
                    result: result
                });
            }
        }
    } else if (player1.type === 'team' && player2.type === 'team') {
        // Team vs Team: find games where they played each other
        const team1Name = player1.name;
        const team2Name = player2.name;
        
        for (const game of games) {
            const isMatchup = (game.team1 === team1Name && game.team2 === team2Name) || 
                             (game.team1 === team2Name && game.team2 === team1Name);
            
            if (isMatchup) {
                let result = 'D';
                if (game.team1 === team1Name) {
                    if (game.score1 > game.score2) result = 'W';
                    else if (game.score1 < game.score2) result = 'L';
                } else {
                    if (game.score2 > game.score1) result = 'W';
                    else if (game.score2 < game.score1) result = 'L';
                }
                
                if (result === 'W') wins++;
                else if (result === 'L') losses++;
                else draws++;
                
                const outcomeOnly = toBool(game.outcome_only ?? game.outcomeOnly);
                const tournamentGame = toBool(game.tournament ?? game.tournamentGame);

                // Points for/against from team1's perspective (player1)
                if (!outcomeOnly) {
                    if (game.team1 === team1Name) {
                        pointsFor += game.score1;
                        pointsAgainst += game.score2;
                    } else {
                        pointsFor += game.score2;
                        pointsAgainst += game.score1;
                    }
                }
                
                const p1Score = game.team1 === team1Name ? game.score1 : game.score2;
                const p2Score = game.team1 === team2Name ? game.score1 : game.score2;
                h2hGames.push({
                    datetime: game.datetime,
                    p1TeamName: team1Name,
                    p2TeamName: team2Name,
                    p1Score,
                    p2Score,
                    outcomeOnly,
                    tournamentGame,
                    result: result
                });
            }
        }
    }
    
    if (h2hGames.length === 0) return null;
    
    // Sort by date descending (most recent first)
    h2hGames.sort((a, b) => new Date(b.datetime) - new Date(a.datetime));
    
    const record = `${wins}-${draws}-${losses}`; // P1 wins - draws - P2 wins
    const pointDiff = pointsFor - pointsAgainst;
    return { record, games: h2hGames, pointDiff, pointsFor, pointsAgainst };
}

function getSharedTeamsData(player1, player2) {
    if (player1.type !== 'player' || player2.type !== 'player') return { rows: [], summary: null };
    const teams1 = DATA.players[player1.name]?.teams || [];
    const teams2 = DATA.players[player2.name]?.teams || [];
    const shared = teams1.filter(t => teams2.includes(t));
    if (shared.length === 0) return { rows: [], summary: null };

    const sharedSet = new Set(shared);
    const rows = shared.map(teamName => {
        const team = DATA.teams[teamName];
        if (!team) return null;
        const summary = TEAM_ELO_SUMMARY[teamName] || {};
        const currentElo = summary.current_elo ?? team.current_elo ?? null;
        const startingElo = summary.starting_elo ?? null;
        const finalElo = summary.final_elo ?? null;
        const eloChange = (finalElo !== null && startingElo !== null) ? (finalElo - startingElo) : null;
        return {
            name: teamName,
            currentElo,
            eloChange,
            finalElo,
            startingElo,
            winPct: team.games > 0 ? (team.wins + 0.5 * team.draws) / team.games : null,
            wins: team.wins,
            losses: team.losses,
            draws: team.draws,
            games: team.games,
            lastGame: team.last_game
        };
    }).filter(Boolean);
    rows.sort((a, b) => {
        const aTime = a.lastGame ? new Date(a.lastGame).getTime() : -Infinity;
        const bTime = b.lastGame ? new Date(b.lastGame).getTime() : -Infinity;
        return bTime - aTime;
    });

    // Aggregate record together on shared teams
    const games = DATA.games_with_scores || [];
    let wins = 0, losses = 0, draws = 0, gamesTogether = 0;
    for (const game of games) {
        let sharedTeamPlayed = null;
        if (sharedSet.has(game.team1)) sharedTeamPlayed = game.team1;
        if (sharedSet.has(game.team2) && !sharedTeamPlayed) sharedTeamPlayed = game.team2;
        if (!sharedTeamPlayed) continue;
        if (game.score1 === undefined || game.score2 === undefined) continue;
        const teamIs1 = sharedTeamPlayed === game.team1;
        const scoreFor = teamIs1 ? game.score1 : game.score2;
        const scoreAgainst = teamIs1 ? game.score2 : game.score1;
        if (scoreFor > scoreAgainst) wins++;
        else if (scoreFor < scoreAgainst) losses++;
        else draws++;
        gamesTogether++;
    }
    const summary = gamesTogether > 0 ? {
        games: gamesTogether,
        wins,
        losses,
        draws,
        winPct: (wins + 0.5 * draws) / gamesTogether
    } : null;

    return { rows, summary };
}

function renderCompareEloChart(item1, item2) {
    const container = document.getElementById('compareEloChart');
    if (!container) return;
    if (!item1 || !item2) {
        container.innerHTML = '';
        return;
    }

    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));

    const findLastChangeIdx = (values) => {
        for (let i = values.length - 1; i > 0; i--) {
            if (values[i] !== values[i - 1]) return i;
        }
        return values.length - 1;
    };

    if (item1.type === 'player' && item2.type === 'player') {
        const p1 = item1.name;
        const p2 = item2.name;
        const elos1 = DATA.elo_history.players[p1];
        const elos2 = DATA.elo_history.players[p2];
        if (!elos1 || !elos2 || elos1.length !== timestamps.length || elos2.length !== timestamps.length) {
            container.innerHTML = '<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;"><p style="color: #999; text-align: center;">ELO history not available for one or both players.</p></div>';
            return;
        }

        const findFirstAndLastGame = (playerName) => {
            const player = DATA.players[playerName];
            if (!player) return { firstGame: null, lastGame: null };
            let firstGame = null;
            let lastGame = player.last_played ? new Date(player.last_played) : null;
            const playerTeams = Array.isArray(player.teams) ? player.teams : [];
            const gamesList = DATA.games_with_scores || DATA.games || [];
            for (const g of gamesList) {
                const dt = new Date(g.datetime);
                if (playerTeams.includes(g.team1) || playerTeams.includes(g.team2)) {
                    if (!firstGame || dt < firstGame) firstGame = dt;
                    if (!lastGame || dt > lastGame) lastGame = dt;
                }
            }
            return { firstGame, lastGame };
        };

        const range1 = findFirstAndLastGame(p1);
        const range2 = findFirstAndLastGame(p2);

        let startIdx = 0;
        const earliestFirstGame = [range1.firstGame, range2.firstGame].filter(Boolean).reduce((a, b) => a && a < b ? a : b, null);
        if (earliestFirstGame) {
            for (let i = timestamps.length - 1; i >= 0; i--) {
                if (timestamps[i] < earliestFirstGame) { startIdx = i; break; }
            }
        }
        startIdx = Math.max(0, startIdx);

        const endIdx = Math.max(findLastChangeIdx(elos1), findLastChangeIdx(elos2));

        const plotTimestamps = timestamps.slice(startIdx, endIdx + 1);
        const plot1 = elos1.slice(startIdx, endIdx + 1);
        const plot2 = elos2.slice(startIdx, endIdx + 1);

        const trace1 = { x: plotTimestamps, y: plot1, mode: 'lines', name: p1, line: { color: '#1f77b4', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+p1+'</extra>' };
        const trace2 = { x: plotTimestamps, y: plot2, mode: 'lines', name: p2, line: { color: '#d62728', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+p2+'</extra>' };
        const baseline = { x: plotTimestamps, y: Array(plotTimestamps.length).fill(INITIAL_ELO), mode: 'lines', name: 'Starting ELO', line: { color: '#888', dash: 'dash', width: 1 }, hoverinfo: 'skip', showlegend: false };

        const lastGameEither = [range1.lastGame, range2.lastGame].filter(Boolean).reduce((a, b) => a && a > b ? a : b, null);
        const shapes = [];
        if (plotTimestamps.length > 0 && lastGameEither) {
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: lastGameEither, y0: 0, y1: 1, fillcolor: 'lightyellow', opacity: 0.45, line: { width: 0 }, layer: 'below' });
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: lastGameEither, x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
        } else if (plotTimestamps.length > 0) {
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
        }

        const layout = {
            title: 'ELO Over Time (Comparison)',
            xaxis: { title: 'Date' },
            yaxis: { title: 'ELO Rating' },
            height: 450,
            hovermode: 'x unified',
            legend: { orientation: 'h', x: 0, y: 1.08, yanchor: 'bottom', bgcolor: 'rgba(255,255,255,0.9)', bordercolor: '#ddd', borderwidth: 1 },
            margin: { t: 40, r: 20, b: 60, l: 60 },
            shapes: shapes
        };

        Plotly.newPlot('compareEloChart', [baseline, trace1, trace2], layout, { responsive: true });
        return;
    }

    if (item1.type === 'team' && item2.type === 'team') {
        const t1 = item1.name;
        const t2 = item2.name;
        const team1 = DATA.teams[t1];
        const team2 = DATA.teams[t2];
        if (!team1 || !team2 || !team1.elo_history || !team2.elo_history) {
            container.innerHTML = '<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;"><p style="color: #999; text-align: center;">ELO history not available for one or both teams.</p></div>';
            return;
        }

        const findTeamFirstLast = (teamName) => {
            const gamesList = DATA.games_with_scores || DATA.games || [];
            let firstGame = null;
            let lastGame = null;
            for (const g of gamesList) {
                if (g.team1 === teamName || g.team2 === teamName) {
                    const dt = new Date(g.datetime);
                    if (!firstGame || dt < firstGame) firstGame = dt;
                    if (!lastGame || dt > lastGame) lastGame = dt;
                }
            }
            return { firstGame, lastGame };
        };

        const range1 = findTeamFirstLast(t1);
        const range2 = findTeamFirstLast(t2);

        let startIdx = 0;
        const earliestFirst = [range1.firstGame, range2.firstGame].filter(Boolean).reduce((a, b) => a && a < b ? a : b, null);
        if (earliestFirst) {
            for (let i = timestamps.length - 1; i >= 0; i--) {
                if (timestamps[i] < earliestFirst) { startIdx = i; break; }
            }
        }
        startIdx = Math.max(0, startIdx);

        const endIdx = Math.max(
            findLastChangeIdx(team1.elo_history || []),
            findLastChangeIdx(team2.elo_history || [])
        );

        const plotTimestamps = timestamps.slice(startIdx, endIdx + 1);
        const plot1 = team1.elo_history.slice(startIdx, endIdx + 1);
        const plot2 = team2.elo_history.slice(startIdx, endIdx + 1);

        const trace1 = { x: plotTimestamps, y: plot1, mode: 'lines', name: t1, line: { color: '#1f77b4', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+t1+'</extra>' };
        const trace2 = { x: plotTimestamps, y: plot2, mode: 'lines', name: t2, line: { color: '#d62728', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+t2+'</extra>' };
        const baseline = { x: plotTimestamps, y: Array(plotTimestamps.length).fill(INITIAL_ELO), mode: 'lines', name: 'Starting ELO', line: { color: '#888', dash: 'dash', width: 1 }, hoverinfo: 'skip', showlegend: false };

        const lastGameEither = [range1.lastGame, range2.lastGame].filter(Boolean).reduce((a, b) => a && a > b ? a : b, null);
        const shapes = [];
        if (plotTimestamps.length > 0 && lastGameEither) {
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: lastGameEither, y0: 0, y1: 1, fillcolor: 'lightyellow', opacity: 0.45, line: { width: 0 }, layer: 'below' });
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: lastGameEither, x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
        } else if (plotTimestamps.length > 0) {
            shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
        }

        const layout = {
            title: 'ELO Over Time (Comparison)',
            xaxis: { title: 'Date' },
            yaxis: { title: 'ELO Rating' },
            height: 450,
            hovermode: 'x unified',
            legend: { orientation: 'h', x: 0, y: 1.08, yanchor: 'bottom', bgcolor: 'rgba(255,255,255,0.9)', bordercolor: '#ddd', borderwidth: 1 },
            margin: { t: 40, r: 20, b: 60, l: 60 },
            shapes: shapes
        };

        Plotly.newPlot('compareEloChart', [baseline, trace1, trace2], layout, { responsive: true });
        return;
    }

    container.innerHTML = '';
}

function formatSharedTeamsData(rows, summary) {
    let html = `<div style="border: 1px solid #ddd; border-radius: 4px; padding: 15px; background: #f8f9fa;">
        <h4 style="margin-top: 0; text-align: center;">Shared Teams</h4>`;
    if (summary) {
        const winPctStr = summary.winPct !== null && summary.winPct !== undefined ? `${(summary.winPct*100).toFixed(1)}%` : 'N/A';
        html += `<p style="text-align: center; font-size: 13px; margin: 0 0 12px 0;">Games together: ${summary.games} • Record: ${summary.wins}-${summary.losses}-${summary.draws} • Win %: ${winPctStr}</p>`;
    }
    html += `<table style="width: 100%; border-collapse: collapse; font-size: 12px;">
            <thead>
                <tr style="background: #e9ecef;">
                    <th style="padding: 6px; text-align: left; border-bottom: 1px solid #ddd; font-size: 11px;">Team</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Current ELO</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Change in ELO</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Final ELO</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Starting ELO</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Win %</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Games</th>
                    <th style="padding: 6px; text-align: center; border-bottom: 1px solid #ddd; font-size: 11px;">Last Played</th>
                </tr>
            </thead>
            <tbody>`;
    html += rows.map(r => {
        const wp = r.winPct !== null && r.winPct !== undefined ? `${(r.winPct*100).toFixed(1)}% (W:${r.wins} L:${r.losses} T:${r.draws})` : 'N/A';
        const lp = r.lastGame ? new Date(r.lastGame).toLocaleDateString() : 'Never';
        const delta = r.eloChange !== null && r.eloChange !== undefined ? `${r.eloChange >= 0 ? '+' : ''}${r.eloChange.toFixed(2)}` : 'N/A';
        return `<tr style="border-bottom: 1px solid #eee;">
            <td style="padding: 6px; font-size: 11px;"><a href="#/team/${encodeURIComponent(r.name)}">${escapeHtml(r.name)}</a></td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${r.currentElo !== null && r.currentElo !== undefined ? r.currentElo.toFixed(2) : 'N/A'}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${delta}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${r.finalElo !== null && r.finalElo !== undefined ? r.finalElo.toFixed(2) : 'N/A'}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${r.startingElo !== null && r.startingElo !== undefined ? r.startingElo.toFixed(2) : 'N/A'}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${wp}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${r.games}</td>
            <td style="padding: 6px; text-align: center; font-size: 11px;">${lp}</td>
        </tr>`;
    }).join('');
    html += '</tbody></table></div>';
    return html;
}

function updateChangesData() {
    const datePicker = document.getElementById('changesDatePicker');
    if (!datePicker) return;
    const selectedDate = new Date(datePicker.value + 'T23:59:59');
    const { players, teams } = computeChanges(selectedDate);
    LAST_CHANGES_DATA = { players: [...players], teams: [...teams] };
    renderChangesTable('playersChangesContainer', players, true);
    renderChangesTable('teamsChangesContainer', teams, false);
}

function computeChanges(targetDate) {
    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));
    const selectedDay = new Date(targetDate.toDateString());
    
    const gamesOnDay = DATA.games_with_scores.filter(g => {
        const gameDate = new Date(g.datetime);
        return gameDate.toDateString() === selectedDay.toDateString();
    });
    
    const teamsPlayed = new Set();
    const teamFirstGame = {};
    gamesOnDay.forEach(g => {
        if (g.team1) {
            teamsPlayed.add(g.team1);
            if (!teamFirstGame[g.team1] || new Date(g.datetime) < new Date(teamFirstGame[g.team1])) {
                teamFirstGame[g.team1] = g.datetime;
            }
        }
        if (g.team2) {
            teamsPlayed.add(g.team2);
            if (!teamFirstGame[g.team2] || new Date(g.datetime) < new Date(teamFirstGame[g.team2])) {
                teamFirstGame[g.team2] = g.datetime;
            }
        }
    });
    
    function getBeforeAfter(values, startTime = null) {
        let afterIdx = -1;
        for (let i = timestamps.length - 1; i >= 0; i--) {
            if (timestamps[i] <= targetDate) {
                afterIdx = i;
                break;
            }
        }
        if (afterIdx < 0) return { before: null, after: null };
        const after = values[afterIdx];
        
        let beforeIdx = -1;
        if (startTime) {
            const start = new Date(startTime);
            for (let i = afterIdx - 1; i >= 0; i--) {
                if (timestamps[i] < start) {
                    beforeIdx = i;
                    break;
                }
            }
        } else {
            beforeIdx = afterIdx - 1;
        }
        const before = beforeIdx >= 0 ? values[beforeIdx] : null;
        return { before, after };
    }
    
    const playerChanges = [];
    Object.entries(DATA.elo_history.players).forEach(([name, values]) => {
        let startTime = null;
        const playerTeams = DATA.players[name]?.teams || [];
        playerTeams.forEach(team => {
            if (teamFirstGame[team]) {
                if (!startTime || new Date(teamFirstGame[team]) < new Date(startTime)) {
                    startTime = teamFirstGame[team];
                }
            }
        });
        const { before, after } = getBeforeAfter(values, startTime);
        if (before !== null && after !== null && before !== after) {
            playerChanges.push({ name, before, after, delta: after - before });
        }
    });
    
    const teamChanges = [];
    Array.from(teamsPlayed).forEach(teamName => {
        const team = DATA.teams[teamName];
        if (!team || !team.elo_history) return;
        const startTime = teamFirstGame[teamName];
        const { before, after } = getBeforeAfter(team.elo_history, startTime);
        if (before !== null && after !== null) {
            const delta = after - before;
            const winPct = team.games > 0 ? (team.wins + 0.5 * team.draws) / team.games : null;
            teamChanges.push({ name: teamName, before, after, delta, wins: team.wins, losses: team.losses, draws: team.draws, win_pct: winPct });
        }
    });
    
    function addRanks(changes) {
        const beforeSorted = [...changes].sort((a, b) => (b.before || 0) - (a.before || 0));
        beforeSorted.forEach((item, idx) => {
            const original = changes.find(c => c.name === item.name);
            if (original) original.rank_before = idx + 1;
        });
        const afterSorted = [...changes].sort((a, b) => (b.after || 0) - (a.after || 0));
        afterSorted.forEach((item, idx) => {
            const original = changes.find(c => c.name === item.name);
            if (original) original.rank_after = idx + 1;
        });
        changes.forEach(item => {
            if (item.rank_before && item.rank_after) {
                // Positive means rank up (better rank number decreases)
                item.rank_change = item.rank_before - item.rank_after;
            }
        });
    }
    
    addRanks(playerChanges);
    addRanks(teamChanges);
    // Defaults handled in render based on changesSort
    
    return { players: playerChanges, teams: teamChanges };
}

function renderChangesTable(containerId, data, isPlayers) {
    if (!data || data.length === 0) {
        document.getElementById(containerId).innerHTML = '<p class="info-text">No changes on selected date.</p>';
        return;
    }
    // Apply current sort
    const sortCfg = isPlayers ? changesSort.players : changesSort.teams;
    sortData(data, sortCfg.column, sortCfg.direction);

    // Build header with sort indicators and click handlers
    const headerClasses = (col) => {
        const isSorted = sortCfg.column === col;
        return isSorted ? (sortCfg.direction === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';
    };
    const sortHandler = (col) => isPlayers ? `sortPlayersChangesTable('${col}')` : `sortTeamsChangesTable('${col}')`;

    let html = '<table class="changes-table"><thead><tr>';
    html += `<th class="${headerClasses('name')}" onclick="${sortHandler('name')}">${isPlayers ? 'Player' : 'Team'}</th>`;
    html += `<th class="${headerClasses('before')}" onclick="${sortHandler('before')}">Before</th>`;
    html += `<th class="${headerClasses('after')}" onclick="${sortHandler('after')}">After</th>`;
    html += `<th class="${headerClasses('delta')}" onclick="${sortHandler('delta')}">Delta</th>`;
    html += `<th class="${headerClasses('rank_before')}" onclick="${sortHandler('rank_before')}">Rank Before</th>`;
    html += `<th class="${headerClasses('rank_after')}" onclick="${sortHandler('rank_after')}">Rank After</th>`;
    html += `<th class="${headerClasses('rank_change')}" onclick="${sortHandler('rank_change')}">Rank Change</th>`;
    if (!isPlayers) html += `<th class="win-pct-col ${headerClasses('win_pct')}" onclick="${sortHandler('win_pct')}">Win %</th>`;
    html += '</tr></thead><tbody>';
    
    data.forEach(item => {
        const link = isPlayers 
            ? `<a href="#/player/${encodeURIComponent(item.name)}">${escapeHtml(item.name)}</a>`
            : `<a href="#/team/${encodeURIComponent(item.name)}">${escapeHtml(item.name)}</a>`;
        const rcVal = (item.rank_change !== null && item.rank_change !== undefined)
            ? (item.rank_change > 0 ? `+${item.rank_change}` : `${item.rank_change}`)
            : '';
        const rcArrow = (item.rank_change !== null && item.rank_change !== undefined)
            ? (item.rank_change > 0 ? '↑' : item.rank_change < 0 ? '↓' : '')
            : '';
        const rcStyle = item.rank_change > 0 ? 'color: green;' : item.rank_change < 0 ? 'color: red;' : '';
        const ds = item.delta > 0 ? 'color: green;' : item.delta < 0 ? 'color: red;' : '';
        html += `<tr><td>${link}</td><td>${item.before?.toFixed(2) ?? 'N/A'}</td><td>${item.after?.toFixed(2) ?? 'N/A'}</td>`;
        html += `<td style="${ds}">${item.delta > 0 ? '+' : ''}${item.delta?.toFixed(2) ?? 'N/A'}</td>`;
        html += `<td>${item.rank_before || 'N/A'}</td><td>${item.rank_after || 'N/A'}</td><td style="${rcStyle}">${rcVal} ${rcArrow}</td>`;
        if (!isPlayers) {
            const wp = item.win_pct !== null && item.win_pct !== undefined ? `${(item.win_pct*100).toFixed(1)}% (W:${item.wins} L:${item.losses} T:${item.draws})` : '';
            html += `<td class="win-pct-col">${wp}</td>`;
        }
        html += '</tr>';
    });
    html += '</tbody></table>';
    document.getElementById(containerId).innerHTML = html;
}

function sortPlayersChangesTable(column) {
    const cfg = changesSort.players;
    if (cfg.column === column) {
        cfg.direction = cfg.direction === 'asc' ? 'desc' : 'asc';
    } else {
        cfg.column = column;
        cfg.direction = column === 'name' ? 'asc' : 'desc';
    }
    renderChangesTable('playersChangesContainer', LAST_CHANGES_DATA.players, true);
}

function sortTeamsChangesTable(column) {
    const cfg = changesSort.teams;
    if (cfg.column === column) {
        cfg.direction = cfg.direction === 'asc' ? 'desc' : 'asc';
    } else {
        cfg.column = column;
        // Default asc for name, desc for numeric
        cfg.direction = column === 'name' ? 'asc' : 'desc';
    }
    renderChangesTable('teamsChangesContainer', LAST_CHANGES_DATA.teams, false);
}

// Player page
function showPlayerPage(playerName) {
    const player = DATA.players[playerName];
    if (!player) {
        document.getElementById('pageContent').innerHTML = `<p>Player not found: ${escapeHtml(playerName)}</p><a href="#/" class="back-link">← Back</a>`;
        return;
    }
    
    const allElos = Object.values(DATA.players).map(p => p.current_elo).filter(e => e !== null).sort((a, b) => b - a);
    const rank = player.current_elo ? allElos.indexOf(player.current_elo) + 1 : null;
    const percentile = rank ? (100 * (allElos.length - rank + 1) / allElos.length).toFixed(1) : null;
    const winPct = player.games > 0 ? (100 * (player.wins + 0.5 * player.draws) / player.games).toFixed(1) : 'N/A';
    
    // Teams the player has been on, default sorted by last played (desc)
    const playerTeamsData = player.teams.map(teamName => {
        const team = DATA.teams[teamName];
        const summary = TEAM_ELO_SUMMARY[teamName] || {};
        if (!team) return null;
        return {
            name: teamName,
            last_game: team.last_game,
            final_elo: summary.final_elo ?? null,
            current_elo: summary.current_elo ?? team.current_elo ?? null,
            starting_elo: summary.starting_elo ?? null,
            win_pct: team.games > 0 ? (team.wins + 0.5 * team.draws) / team.games : null,
            wins: team.wins,
            losses: team.losses,
            draws: team.draws,
            games: team.games
        };
    }).filter(Boolean);

    playerTeamsData.sort((a, b) => {
        const aTime = a.last_game ? new Date(a.last_game).getTime() : -Infinity;
        const bTime = b.last_game ? new Date(b.last_game).getTime() : -Infinity;
        return bTime - aTime;
    });

    let teamsTable = '<table class="roster-table"><thead><tr><th>Team</th><th>Final ELO</th><th>Current ELO</th><th>Starting ELO</th><th class="roster-win-pct">Win %</th><th>Games</th><th>Last Played</th></tr></thead><tbody>';
    playerTeamsData.forEach(t => {
        const lp = t.last_game ? new Date(t.last_game).toLocaleDateString() : 'Never';
        const wp = t.win_pct !== null ? `${(t.win_pct*100).toFixed(1)}% (W:${t.wins} L:${t.losses} T:${t.draws})` : 'N/A';
        teamsTable += `<tr>`;
        teamsTable += `<td><a href="#/team/${encodeURIComponent(t.name)}">${escapeHtml(t.name)}</a></td>`;
        teamsTable += `<td>${t.final_elo?.toFixed(2) ?? 'N/A'}</td>`;
        teamsTable += `<td>${t.current_elo?.toFixed(2) ?? 'N/A'}</td>`;
        teamsTable += `<td>${t.starting_elo?.toFixed(2) ?? 'N/A'}</td>`;
        teamsTable += `<td class="roster-win-pct">${wp}</td>`;
        teamsTable += `<td>${t.games}</td>`;
        teamsTable += `<td>${lp}</td>`;
        teamsTable += `</tr>`;
    });
    teamsTable += '</tbody></table>';
    
    let html = `<a href="#/" class="back-link">← Back to Players</a>
        <div class="player-summary">
            <h2>${escapeHtml(playerName)}</h2>
            <p><strong>ELO:</strong> ${player.current_elo?.toFixed(2) ?? 'N/A'}${rank ? ` (Rank #${rank}, ${percentile}th percentile)` : ''}</p>
            <p><strong>Peak ELO:</strong> ${player.peak_elo?.toFixed(2) ?? 'N/A'}</p>
            <p><strong>Min ELO:</strong> ${player.min_elo?.toFixed(2) ?? 'N/A'}</p>
            <p><strong>Record:</strong> ${player.wins}-${player.losses}-${player.draws} (${winPct}%)</p>
            <p><strong>Games:</strong> ${player.games}</p>
        </div>
        <div class="player-chart-block"><div id="playerChart"></div></div>
        <div class="player-teams-block"><h3>Teams</h3>${teamsTable}</div>`;
    
    document.getElementById('pageContent').innerHTML = html;
    renderPlayerChart(playerName);
}

// Team page
function showTeamPage(teamName) {
    const team = DATA.teams[teamName];
    if (!team) {
        document.getElementById('pageContent').innerHTML = `<p>Team not found: ${escapeHtml(teamName)}</p><a href="#/teams" class="back-link">← Back</a>`;
        return;
    }
    
    const teamElo = TEAM_ELO_SUMMARY[teamName] || {};
    const allTeamFinalElos = Object.values(TEAM_ELO_SUMMARY).map(t => t.final_elo).filter(e => e !== null).sort((a, b) => b - a);
    const finalRank = teamElo.final_elo !== null && teamElo.final_elo !== undefined ? allTeamFinalElos.indexOf(teamElo.final_elo) + 1 : null;
    const finalPercentile = finalRank ? (100 * (allTeamFinalElos.length - finalRank + 1) / allTeamFinalElos.length).toFixed(1) : null;

    const allTeamCurrentElos = Object.values(DATA.teams).map(t => t.current_elo).filter(e => e !== null).sort((a, b) => b - a);
    const currentRank = team.current_elo ? allTeamCurrentElos.indexOf(team.current_elo) + 1 : null;
    const currentPercentile = currentRank ? (100 * (allTeamCurrentElos.length - currentRank + 1) / allTeamCurrentElos.length).toFixed(1) : null;
    const winPct = team.games > 0 ? (100 * (team.wins + 0.5 * team.draws) / team.games).toFixed(1) : 'N/A';
    
    let rosterTable = '<table class="roster-table"><thead><tr>';
    
    // Build roster data
    const allPlayerElos = Object.entries(DATA.players).map(([name, stats]) => ({ name, elo: stats.current_elo })).filter(p => p.elo !== null).sort((a, b) => b.elo - a.elo);
    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));
    const rosterData = [];
    
    team.members.forEach(playerName => {
        const player = DATA.players[playerName];
        if (!player) return;
        
        const pRank = player.current_elo ? allPlayerElos.findIndex(p => p.name === playerName) + 1 : null;
        const pPercentile = pRank ? (100 * (allPlayerElos.length - pRank + 1) / allPlayerElos.length).toFixed(1) : null;
        
        const playerEloHistory = DATA.elo_history.players[playerName];
        let endingElo = null;
        let startingElo = null;
        
        // Ending ELO: player's ELO at or after team's last game
        if (team.last_game && playerEloHistory) {
            const lastGameDate = new Date(team.last_game);
            for (let i = 0; i < timestamps.length; i++) {
                if (timestamps[i] >= lastGameDate) {
                    endingElo = playerEloHistory[i];
                    break;
                }
            }
        }
        
        // Starting ELO: player's ELO just before team's first game
        if (team.first_game && playerEloHistory) {
            const firstGameDate = new Date(team.first_game);
            for (let i = timestamps.length - 1; i >= 0; i--) {
                if (timestamps[i] < firstGameDate) {
                    startingElo = playerEloHistory[i];
                    break;
                }
            }
        }
        
        // Previous games: count games where player's team was involved before team's first game
        let prevGames = 0;
        if (team.first_game) {
            const firstGameDate = new Date(team.first_game);
            const gamesBeforeFirst = DATA.games_with_scores.filter(g => new Date(g.datetime) < firstGameDate);
            gamesBeforeFirst.forEach(g => {
                if ((g.team1 && player.teams.includes(g.team1)) || (g.team2 && player.teams.includes(g.team2))) {
                    prevGames++;
                }
            });
        }
        
        rosterData.push({
            name: playerName,
            current_elo: player.current_elo ?? null,
            rank: pRank,
            percentile: pPercentile,
            ending_elo: endingElo,
            starting_elo: startingElo,
            prev_games: prevGames
        });
    });
    
    // Sort and store roster data
    LAST_ROSTER_DATA = rosterData;
    LAST_ROSTER_TEAM = teamName;
    sortData(rosterData, rosterSort.column, rosterSort.direction);
    
    // Build table with sortable headers
    const rosterHeaderClasses = (col) => {
        const isSorted = rosterSort.column === col;
        return isSorted ? (rosterSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';
    };
    const rosterSortHandler = (col) => `sortRosterTable('${col}')`;
    rosterTable += `<th class="${rosterHeaderClasses('name')}" onclick="${rosterSortHandler('name')}">Player</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('current_elo')}" onclick="${rosterSortHandler('current_elo')}">ELO</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('rank')}" onclick="${rosterSortHandler('rank')}">Rank</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('percentile')}" onclick="${rosterSortHandler('percentile')}">Percentile</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('ending_elo')}" onclick="${rosterSortHandler('ending_elo')}">Ending ELO</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('starting_elo')}" onclick="${rosterSortHandler('starting_elo')}">Starting ELO</th>`;
    rosterTable += `<th class="${rosterHeaderClasses('prev_games')}" onclick="${rosterSortHandler('prev_games')}">Previous Games</th>`;
    rosterTable += '</tr></thead><tbody>';
    
    rosterData.forEach(r => {
        rosterTable += `<tr><td><a href="#/player/${encodeURIComponent(r.name)}">${escapeHtml(r.name)}</a></td>`;
        rosterTable += `<td>${r.current_elo?.toFixed(2) ?? 'N/A'}</td><td>${r.rank ? `#${r.rank}` : 'N/A'}</td>`;
        rosterTable += `<td>${r.percentile ? `${r.percentile}%` : 'N/A'}</td>`;
        rosterTable += `<td>${r.ending_elo ? r.ending_elo.toFixed(2) : 'N/A'}</td>`;
        rosterTable += `<td>${r.starting_elo ? r.starting_elo.toFixed(2) : 'N/A'}</td>`;
        rosterTable += `<td>${r.prev_games}</td></tr>`;
    });
    rosterTable += '</tbody></table>';
    
    let html = `<a href="#/teams" class="back-link">← Back to Teams</a>
        <div class="detail-info">
            <h2>${escapeHtml(teamName)}</h2>
            <p><strong>Final ELO (post last game):</strong> ${teamElo.final_elo?.toFixed(2) ?? 'N/A'}${finalRank ? ` (Rank #${finalRank}, ${finalPercentile}th percentile)` : ''}</p>
            <p><strong>Current ELO:</strong> ${teamElo.current_elo?.toFixed(2) ?? team.current_elo?.toFixed(2) ?? 'N/A'}${currentRank ? ` (Rank #${currentRank}, ${currentPercentile}th percentile)` : ''}</p>
            <p><strong>Starting ELO (pre first game):</strong> ${teamElo.starting_elo?.toFixed(2) ?? 'N/A'}</p>
            <p><strong>Record:</strong> ${team.wins}-${team.losses}-${team.draws} (${winPct}%)</p>
            <p><strong>Games:</strong> ${team.games}</p>
            <p><strong>First Game:</strong> ${team.first_game ? new Date(team.first_game).toLocaleDateString() : 'Never'}</p>
            <p><strong>Last Game:</strong> ${team.last_game ? new Date(team.last_game).toLocaleDateString() : 'Never'}</p>
        </div>
        <div class="team-chart-block"><div id="teamChart"></div></div>
        <div class="player-teams-block"><h3>Roster</h3>${rosterTable}</div>`;
    
    document.getElementById('pageContent').innerHTML = html;
    renderTeamChart(teamName);
}

// Player chart
function renderPlayerChart(playerName) {
    const playerElos = DATA.elo_history.players[playerName];
    if (!playerElos) return;
    
    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));
    const player = DATA.players[playerName];
    
    function findPlayerFirstAndLastGame() {
        if (!player) return { firstGame: null, lastGame: null };
        let firstGame = null;
        let lastGame = player.last_played ? new Date(player.last_played) : null;
        const playerTeams = Array.isArray(player.teams) ? player.teams : [];
        const gamesList = DATA.games_with_scores || DATA.games || [];
        for (const g of gamesList) {
            const dt = new Date(g.datetime);
            if (playerTeams.includes(g.team1) || playerTeams.includes(g.team2)) {
                if (!firstGame || dt < firstGame) firstGame = dt;
                if (!lastGame || dt > lastGame) lastGame = dt;
            }
        }
        return { firstGame, lastGame };
    }

    function findLastChangeIdx(values) {
        for (let i = values.length - 1; i > 0; i--) {
            if (values[i] !== values[i - 1]) return i; // index of last change
        }
        return values.length - 1; // fallback to latest
    }

    const { firstGame, lastGame } = findPlayerFirstAndLastGame();
    let startIdx = 0;
    if (firstGame) {
        for (let i = timestamps.length - 1; i >= 0; i--) {
            if (timestamps[i] < firstGame) { startIdx = i; break; }
        }
    }
    startIdx = Math.max(0, startIdx);
    const lastChangeIdx = findLastChangeIdx(playerElos);
    let endIdx = lastChangeIdx;
    
    const plotTimestamps = timestamps.slice(startIdx, endIdx + 1);
    const plotElos = playerElos.slice(startIdx, endIdx + 1);
    const traces = [{ x: plotTimestamps, y: plotElos, mode: 'lines', name: playerName, line: { color: 'blue', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+playerName+'</extra>' }];
    
    const colors = ['red', 'green', 'purple', 'orange', 'brown'];
    player.teams.forEach((teamName, idx) => {
        const team = DATA.teams[teamName];
        if (!team || !team.elo_history) return;
        const teamGames = DATA.games.filter(g => g.team1 === teamName || g.team2 === teamName);
        if (teamGames.length === 0) return;
        const teamGameDates = teamGames.map(g => new Date(g.datetime));
        const teamFirst = new Date(Math.min(...teamGameDates));
        const teamLast = new Date(Math.max(...teamGameDates));
        let tStart = 0, tEnd = timestamps.length - 1;
        for (let i = 0; i < timestamps.length; i++) {
            if (timestamps[i] < teamFirst) tStart = i;
            if (timestamps[i] <= teamLast) tEnd = i;
        }
        tStart = Math.max(0, tStart);
        const teamPlotTimestamps = timestamps.slice(tStart, tEnd + 1);
        const teamPlotElos = team.elo_history.slice(tStart, tEnd + 1);
        traces.push({ x: teamPlotTimestamps, y: teamPlotElos, mode: 'lines', name: teamName, line: { color: colors[idx % colors.length], dash: 'dash', width: 2 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+teamName+'</extra>' });
    });
    
    traces.push({ x: plotTimestamps, y: Array(plotTimestamps.length).fill(INITIAL_ELO), mode: 'lines', name: 'Starting ELO', line: { color: 'red', dash: 'dash', width: 1 }, hoverinfo: 'skip', showlegend: false });
    const shapes = [];
    // Match team page: lightyellow from start through last game, lightblue after last game
    if (plotTimestamps.length > 0 && lastGame) {
        shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: new Date(lastGame), y0: 0, y1: 1, fillcolor: 'lightyellow', opacity: 0.45, line: { width: 0 }, layer: 'below' });
        shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: new Date(lastGame), x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
    } else if (plotTimestamps.length > 0) {
        // Fallback: all lightblue if no last game date
        shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: plotTimestamps[0], x1: plotTimestamps[plotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
    }
    const layout = {
        title: '',
        xaxis: { title: 'Date' },
        yaxis: { title: 'ELO Rating' },
        height: 600,
        hovermode: 'x unified',
        legend: {
            orientation: 'h',
            x: 0,
            y: 1.08,
            yanchor: 'bottom',
            bgcolor: 'rgba(255,255,255,0.9)',
            bordercolor: '#ddd',
            borderwidth: 1
        },
        margin: { t: 40, r: 20, b: 60, l: 60 },
        shapes: shapes
    };
    Plotly.newPlot('playerChart', traces, layout, { responsive: true });
}

// Team chart
function renderTeamChart(teamName) {
    const team = DATA.teams[teamName];
    if (!team || !team.elo_history) return;
    
    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));
    const colors = ['blue', 'green', 'red', 'purple', 'orange', 'brown', 'pink', 'gray'];
    const playerRanges = [];
    let earliestStartIdx = null;
    let latestEndIdx = null;

    function findPlayerGameRange(playerName) {
        const player = DATA.players[playerName];
        if (!player) return null;
        const playerElos = DATA.elo_history.players[playerName];
        if (!playerElos || !Array.isArray(playerElos) || playerElos.length !== timestamps.length) return null;
        // Determine first and last game dates for the player across all their teams
        let firstGame = null;
        let lastGame = player.last_played ? new Date(player.last_played) : null;
        const playerTeams = Array.isArray(player.teams) ? player.teams : [];
        // Use games_with_scores for consistency with player stats
        const gamesList = DATA.games_with_scores || DATA.games || [];
        for (const g of gamesList) {
            const dt = new Date(g.datetime);
            if (playerTeams.includes(g.team1) || playerTeams.includes(g.team2)) {
                if (!firstGame || dt < firstGame) firstGame = dt;
                if (!lastGame || dt > lastGame) lastGame = dt;
            }
        }
        if (!firstGame || !lastGame) return null;
        // Map to indices: start = last timestamp strictly before firstGame; end = first timestamp on/after lastGame
        let startIdx = 0;
        for (let i = timestamps.length - 1; i >= 0; i--) {
            if (timestamps[i] < firstGame) { startIdx = i; break; }
        }
        let endIdx = timestamps.length - 1;
        for (let i = 0; i < timestamps.length; i++) {
            if (timestamps[i] >= lastGame) { endIdx = i; break; }
        }
        return { startIdx, endIdx, playerElos };
    }

    team.members.forEach((playerName, idx) => {
        const range = findPlayerGameRange(playerName);
        if (!range) return;
        const plotTimestamps = timestamps.slice(range.startIdx, range.endIdx + 1);
        const plotElos = range.playerElos.slice(range.startIdx, range.endIdx + 1);
        playerRanges.push({ plotTimestamps, plotElos, startIdx: range.startIdx, endIdx: range.endIdx, color: colors[idx % colors.length], name: playerName });
        if (earliestStartIdx === null || range.startIdx < earliestStartIdx) earliestStartIdx = range.startIdx;
        if (latestEndIdx === null || range.endIdx > latestEndIdx) latestEndIdx = range.endIdx;
    });

    if (playerRanges.length === 0 || earliestStartIdx === null || latestEndIdx === null) return;

    // Sort player ranges by current ELO (descending) so they appear in order in hover
    playerRanges.sort((a, b) => {
        const aElo = DATA.players[a.name]?.current_elo ?? 0;
        const bElo = DATA.players[b.name]?.current_elo ?? 0;
        return bElo - aElo;
    });

    // Team line spans from just before the earliest player game through the latest player game
    const teamStartIdx = Math.max(0, earliestStartIdx);
    const teamEndIdx = Math.min(timestamps.length - 1, latestEndIdx);
    const teamPlotTimestamps = timestamps.slice(teamStartIdx, teamEndIdx + 1);
    const teamPlotElos = team.elo_history.slice(teamStartIdx, teamEndIdx + 1);

    const traces = [{ x: teamPlotTimestamps, y: teamPlotElos, mode: 'lines+markers', name: `${teamName} (Team Avg)`, line: { color: 'black', width: 3 }, marker: { size: 6 }, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+teamName+'</extra>' }];
    playerRanges.forEach(r => {
        traces.push({ x: r.plotTimestamps, y: r.plotElos, mode: 'lines', name: r.name, line: { color: r.color, width: 1.5 }, opacity: 0.7, hovertemplate: '%{x|%m/%d/%Y %H:%M}: %{y:.0f}<extra>'+r.name+'</extra>' });
    });

    traces.push({ x: teamPlotTimestamps, y: Array(teamPlotTimestamps.length).fill(INITIAL_ELO), mode: 'lines', name: 'Starting ELO', line: { color: 'red', dash: 'dash', width: 1 }, hoverinfo: 'skip', showlegend: false });
    const shapes = [];
    shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: teamPlotTimestamps[0], x1: teamPlotTimestamps[teamPlotTimestamps.length - 1], y0: 0, y1: 1, fillcolor: 'lightblue', opacity: 0.35, line: { width: 0 }, layer: 'below' });
    if (team.first_game && team.last_game) {
        shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: new Date(team.first_game), x1: new Date(team.last_game), y0: 0, y1: 1, fillcolor: 'lightyellow', opacity: 0.45, line: { width: 0 }, layer: 'below' });
    }
    const layout = {
        title: '',
        xaxis: { title: 'Date' },
        yaxis: { title: 'Team ELO Rating' },
        height: 600,
        hovermode: 'x unified',
        legend: {
            orientation: 'h',
            x: 0,
            y: 1.12,
            yanchor: 'bottom',
            bgcolor: 'rgba(255,255,255,0.9)',
            bordercolor: '#ddd',
            borderwidth: 1
        },
        margin: { t: 20, r: 20, b: 60, l: 60 },
        shapes: shapes
    };
    Plotly.newPlot('teamChart', traces, layout, { responsive: true });
}

// Utilities
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Compute team starting/final/current ELOs by averaging member player ELOs at timestamps:
// - starting: last timestamp strictly before first_game (or null if none)
// - final: first timestamp >= last_game (or latest if none found)
// - current: latest timestamp in the history
function computeTeamEloSummary() {
    const summary = {};
    if (!DATA || !DATA.elo_history || !DATA.elo_history.players || !DATA.elo_history.timestamps) return summary;

    const timestamps = DATA.elo_history.timestamps.map(t => new Date(t));
    const lastIdx = timestamps.length - 1;
    const playersHistory = DATA.elo_history.players;

    function avgAtIdx(members, idx) {
        const vals = members
            .map(m => playersHistory[m]?.[idx])
            .filter(v => v !== undefined && v !== null);
        if (vals.length === 0) return null;
        const total = vals.reduce((a, b) => a + b, 0);
        return total / vals.length;
    }

    Object.entries(DATA.teams).forEach(([teamName, teamData]) => {
        const members = teamData.members || [];
        // starting index: last timestamp before first_game
        let startingIdx = null;
        if (teamData.first_game) {
            const fg = new Date(teamData.first_game);
            for (let i = timestamps.length - 1; i >= 0; i--) {
                if (timestamps[i] < fg) {
                    startingIdx = i;
                    break;
                }
            }
        }
        // final index: first timestamp on/after last_game (fallback latest)
        let finalIdx = lastIdx;
        if (teamData.last_game) {
            const lg = new Date(teamData.last_game);
            for (let i = 0; i < timestamps.length; i++) {
                if (timestamps[i] >= lg) {
                    finalIdx = i;
                    break;
                }
            }
        }
        const startingElo = startingIdx !== null ? avgAtIdx(members, startingIdx) : null;
        const finalElo = avgAtIdx(members, finalIdx);
        const currentElo = avgAtIdx(members, lastIdx);
        summary[teamName] = { starting_elo: startingElo, final_elo: finalElo, current_elo: currentElo, final_idx: finalIdx, starting_idx: startingIdx };
    });

    return summary;
}

function sortData(arr, column, direction) {
    const dateColumns = new Set(['last_played', 'last_game']);
    arr.sort((a, b) => {
        let aVal = a[column], bVal = b[column];
        // Handle nulls: push null/undefined to bottom
        if (aVal === null || aVal === undefined) return 1;
        if (bVal === null || bVal === undefined) return -1;
        // Compare dates if applicable
        if (dateColumns.has(column)) {
            const aTime = new Date(aVal).getTime();
            const bTime = new Date(bVal).getTime();
            const cmpDate = aTime < bTime ? -1 : aTime > bTime ? 1 : 0;
            return direction === 'asc' ? cmpDate : -cmpDate;
        }
        // Normalize strings for case-insensitive compare
        if (typeof aVal === 'string') { aVal = aVal.toLowerCase(); bVal = bVal.toLowerCase(); }
        const cmp = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        return direction === 'asc' ? cmp : -cmp;
    });
}

function sortPlayersTable(column) {
    if (currentSort.column === column && currentSort.table === 'players') {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        currentSort = { table: 'players', column, direction: column === 'name' ? 'asc' : 'desc' };
    }
    showPlayersTab();
}

function sortTeamsTable(column) {
    if (currentSort.column === column && currentSort.table === 'teams') {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        currentSort = { table: 'teams', column, direction: column === 'name' ? 'asc' : 'desc' };
    }
    showTeamsTab();
}

function updateSortIndicators(tableId, column, direction) {
    const table = document.getElementById(tableId);
    if (!table) return;
    const columnMap = {
        // players table
        'name': 0,
        'current_elo': 1,
        'peak_elo': 2,
        'min_elo': 3,
        'win_pct': 4,
        'games': 5,
        'last_played': 6,
        // teams table (ordered as rendered: team, current_elo_avg, change_elo, final_elo, starting_elo, win_pct, games, last_game)
        'current_elo_avg': 1,
        'change_elo': 2,
        'final_elo': 3,
        'starting_elo': 4,
        'win_pct': 5,
        'games': 6,
        'last_game': 7
    };
    const headers = table.querySelectorAll('th');
    headers.forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
    const headerIdx = columnMap[column];
    if (headerIdx !== undefined && headers[headerIdx]) {
        headers[headerIdx].classList.add(direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
    }
}

function filterTable(tableId, columnIndex) {
    const input = document.querySelector('.filter-input');
    if (!input) return;
    const filter = input.value.toLowerCase();
    const table = document.getElementById(tableId);
    if (!table) return;
    const rows = table.getElementsByTagName('tr');
    for (let i = 1; i < rows.length; i++) {
        const cell = rows[i].getElementsByTagName('td')[columnIndex];
        if (cell) {
            const text = cell.textContent || cell.innerText;
            rows[i].style.display = text.toLowerCase().indexOf(filter) > -1 ? '' : 'none';
        }
    }
}
    </script>
</body>
</html>
